# -*- coding: utf-8 -*-
"""test 2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1T4K0DK5Eg_MbPDtSPmPoDhAztBcYuROm

Question 1(FINISHED)
"""

org_array = [1,2,3,4,4,6,6,6] #intiate an array

def remove_dups(x): #method for filtering out duplicates
  lis = []

  for element in x: #intiate for loop
    if element not in lis:
      lis.append(element) #adds all the elements

  return lis #returns sorted list

print(remove_dups(org_array))

"""Question 2(FINISHED)"""

def expression(list_operation): #intiating a method

	arr = [] #intiate an empty array

	for x in func[::-1]: #intiate a for loop
		if number(x):
    
			arr.append(int(x)) #adds elements
   
		else:
			first = arr.pop() #removing a specific item
   
			second = arr.pop() #removig a second specific item

			if x == '+':
				arr.append(first + second) #appending elements addtion

			elif x == '-':
				arr.append(first - second) #appending elements subtraction

			elif x == '*':
				arr.append(first * second) #appending elements multiplication

			elif x == '/':
				arr.append(first / second) #appending elements division

	return arr.pop()

arr_2=["2", "1", "+", "4", "*"]

func=""

for x in arr_2[::-1]:

  func+=x

def number(x):

	return x.isdigit()
 
expression(func)

"""Question 3(FINISHED)"""

class Node:
    def __init__(self, new_data): #intiate an innit method

        self.data = new_data

        self.next = None

class LinkedList: #intiate another class

    def __init__(self): #intiate another innit method

        self.head = None
 

    def push(self, new_data): #create a method for push

        new_node = Node(new_data)

        new_node.next = self.head

        self.head = new_node
 
    def deleteNode(self, n): #create another methor for deleting a node

        first = self.head

        second = self.head

        for i in range(n):
             

            if(second.next == None):
                 

                if(i == n - 1):

                    self.head = self.head.next

                return self.head

            second = second.next
         
        while(second.next != None):

            second = second.next

            first = first.next
         
        first.next = first.next.next
     
    def printList(self): #intiate a method to return updated list

        tmp_head = self.head

        while(tmp_head != None):

            print(tmp_head.data, end = ' ')

            tmp_head = tmp_head.next
         

llist = LinkedList()

llist.push(18)

llist.push(5)

llist.push(7)

llist.push(1)

llist.push(3)

llist.push(2)

llist.printList()

llist.deleteNode(3)

llist.printList()

"""Question 4(FINISHED)"""

class Node:
	
	def __init__(self, x):
		self.info = x
		self.L = None
		self.R = None
		self.C = 0


def finder (sor, k):

	if (sor == None):
   
		return None

	calc = sor.C + 1

	if (calc == k):
   
		return sor

	if (calc > k):
   
		return finder(sor.L, k)
  
	return finder(sor.R, k - calc)
 
def insert(sor, x):
	
	if (sor == None):
   
		return Node(x)
  
	if (x < sor.info):
   
		sor.L = insert(sor.L, x)
  
		sor.C += 1

	elif (x > sor.info):
   
		sor.R = insert(sor.R, x);

	return sor

 
sor = None
numbers = [4,2,6,1,3,5,7]

for x in numbers:
		sor = insert(sor, x)

res = finder(sor, 3)

print("3rd Element is: ", res.info)

"""Question 5(FINISHED)"""

def mergeSort(arr):  #create a method for merge sort
	if len(arr) > 1: # create an if loop

		middle = len(arr)//2 # to find the middle element


		Left = arr[:middle] #to find the left side of array

		Right = arr[middle:] #to find the right side of array


		mergeSort(Left)


		mergeSort(Right)

		i = j = k = 0


		while i < len(Left) and j < len(Right): #create a while loop with 2 condtions
			if Left[i] <= Right[j]:
				arr[k] = Left[i]
				i += 1
			else:
				arr[k] = Right[j]
				j += 1
			k += 1


		while i < len(Left):
			arr[k] = Left[i]
			i += 1
			k += 1

		while j < len(Right):
			arr[k] = Right[j]
			j += 1
			k += 1




def printList(arr): #create another method to prinf array
	for i in range(len(arr)):
		print(arr[i], end=" ")
	print()



if __name__ == '__main__': #used to print updated array
	arr = [50, 11, 33, 21, 40, 50, 40, 40, 21]
	printList(arr)

"""Question 6(FINISHED)"""

def binarySearch(num, l, r, tar): #create a method called binary search
 

    if l > r:
        return -1

 
    m = (l + r) // 2
 

    if tar == num[m]:
        return m
 
    elif tar < num[m]:
        return binarySearch(num, l, m - 1, tar)
 
    else:
        return binarySearch(num, m + 1, r, tar)
 
 
if __name__ == '__main__':
 
    num = [11, 21, 33, 40, 50]
    tar = 21
 
    (l, r) = (0, len(num) - 1)
    position = binarySearch(num, l, r, tar)
 
    if position != -1:
        print('found at position', position)
    else:
        print('not in the list')

"""Question 7(FINISHED)"""

class Node:
  def __init__(self, data):
    self.left = None
    self.right = None
    self.data = data
  
  def insert(self, data):
    if self.data is None:
      self.data = data
    else:
      if data < self.data:
        if self.left is None:
          self.left = Node(data)
        else:
          self.left.insert(data)
      elif data > self.data:
        if self.right is None:
          self.right = Node(data)
        else:
          self.right.insert(data)

  def inorderTraverse(tree, array = []):
    if tree is not None:
      inorderTraverse(tree.left, array)
      array.append(tree.value)
      inorderTraverse(tree.right, array)
    return array

  def preorderTraverse(tree, array = []):
    if tree is not None:
      array.append(tree.value)
      preorderTraverse(tree.left,array)
      preorderTraverse(tree.right, array)
    return array



root = Node(82)
root.insert(28)
root.insert(8)
root.insert(2)
root.insert(182)
root.insert(1824)
root.insert(824)
root.insert(183)

class BinarySearchTree:
  def __init__(self, value):
    self.value = value
    self.left = None
    self.right = None

def inorderTraverse(tree, array = [82,28]):
  if tree is not None:
    inorderTraverse(tree.left, array)
    array.append(tree.value)
    inorderTraverse(tree.right, array)
  return array

def preorderTraverse(tree, array = []):
  if tree is not None:
    array.append(tree.value)
    preorderTraverse(tree.left,array)
    preorderTraverse(tree.right, array)
  return array

def postorderTraverse(tree,array =[]):
  if tree is not None:
    inorderTraverse(tree.left, array)
    inorderTraverse(tree.right, array)
    array.append(tree.value)
  return array


Node1 = BinarySearchTree(82)
Node2 = BinarySearchTree(28)
Node3 = BinarySearchTree(8)
Node4 = BinarySearchTree(2)
Node5 = BinarySearchTree(182)
Node6 = BinarySearchTree(1824)
Node7 = BinarySearchTree(824)
Node8 = BinarySearchTree(183)
Node9 = BinarySearchTree(1)
Node10 = BinarySearchTree(3)
Node11 = BinarySearchTree(5)